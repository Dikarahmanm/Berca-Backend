using Microsoft.EntityFrameworkCore;
using Berca_Backend.Data;
using Berca_Backend.Services.Interfaces;
using Berca_Backend.DTOs;
using Berca_Backend.Models;
using System.Globalization;

namespace Berca_Backend.Services
{
    /// <summary>
    /// Service implementation for calendar event management
    /// Handles business event scheduling, reminders, and auto-generation
    /// Indonesian business context with timezone support
    /// </summary>
    public class CalendarEventService : ICalendarEventService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<CalendarEventService> _logger;
        private readonly TimeZoneInfo _jakartaTimeZone;
        private readonly CultureInfo _indonesianCulture;

        public CalendarEventService(
            AppDbContext context,
            ILogger<CalendarEventService> logger)
        {
            _context = context;
            _logger = logger;
            _jakartaTimeZone = TimeZoneInfo.FindSystemTimeZoneById("SE Asia Standard Time"); // Jakarta timezone
            _indonesianCulture = new CultureInfo("id-ID");
        }

        // ==================== CALENDAR EVENT CRUD ==================== //

        public async Task<CalendarEventPagedResponseDto> GetEventsAsync(CalendarEventQueryParams queryParams, int requestingUserId)
        {
            var query = _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .Where(e => e.IsActive || queryParams.IncludeInactive)
                .AsQueryable();

            // Apply filters
            if (queryParams.StartDate.HasValue)
                query = query.Where(e => e.StartDate >= queryParams.StartDate.Value);

            if (queryParams.EndDate.HasValue)
                query = query.Where(e => e.StartDate <= queryParams.EndDate.Value);

            if (queryParams.EventType.HasValue)
                query = query.Where(e => e.EventType == queryParams.EventType.Value);

            if (queryParams.Priority.HasValue)
                query = query.Where(e => e.Priority == queryParams.Priority.Value);

            if (queryParams.BranchId.HasValue)
                query = query.Where(e => e.BranchId == queryParams.BranchId.Value || e.BranchId == null);

            if (queryParams.IsAutoGenerated.HasValue)
                query = query.Where(e => e.IsAutoGenerated == queryParams.IsAutoGenerated.Value);

            if (!string.IsNullOrWhiteSpace(queryParams.SearchTerm))
            {
                var searchTerm = queryParams.SearchTerm.ToLower();
                query = query.Where(e => e.Title.ToLower().Contains(searchTerm) ||
                                        (e.Description != null && e.Description.ToLower().Contains(searchTerm)));
            }

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            // Get total count
            var totalCount = await query.CountAsync();

            // Apply pagination
            var events = await query
                .OrderBy(e => e.StartDate)
                .Skip((queryParams.Page - 1) * queryParams.PageSize)
                .Take(queryParams.PageSize)
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            // Populate related entity details
            await PopulateRelatedEntityDetails(events);

            var totalPages = (int)Math.Ceiling((double)totalCount / queryParams.PageSize);

            return new CalendarEventPagedResponseDto
            {
                Events = events,
                TotalCount = totalCount,
                Page = queryParams.Page,
                PageSize = queryParams.PageSize,
                TotalPages = totalPages,
                HasNextPage = queryParams.Page < totalPages,
                HasPreviousPage = queryParams.Page > 1
            };
        }

        public async Task<List<CalendarEventDto>> GetEventsByDateRangeAsync(DateTime startDate, DateTime endDate, int? branchId, int requestingUserId)
        {
            var query = _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .Where(e => e.IsActive &&
                           e.StartDate >= startDate &&
                           e.StartDate <= endDate);

            if (branchId.HasValue)
                query = query.Where(e => e.BranchId == branchId.Value || e.BranchId == null);

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            var events = await query
                .OrderBy(e => e.StartDate)
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            await PopulateRelatedEntityDetails(events);
            return events;
        }

        public async Task<CalendarEventDto?> GetEventByIdAsync(int eventId, int requestingUserId)
        {
            var canAccess = await CanUserAccessEventAsync(eventId, requestingUserId);
            if (!canAccess)
                return null;

            var eventEntity = await _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .FirstOrDefaultAsync(e => e.Id == eventId);

            if (eventEntity == null)
                return null;

            var eventDto = new CalendarEventDto
            {
                Id = eventEntity.Id,
                Title = eventEntity.Title,
                Description = eventEntity.Description,
                StartDate = eventEntity.StartDate,
                EndDate = eventEntity.EndDate,
                IsAllDay = eventEntity.IsAllDay,
                EventType = eventEntity.EventType,
                Priority = eventEntity.Priority,
                ActionUrl = eventEntity.ActionUrl,
                RelatedEntityId = eventEntity.RelatedEntityId,
                RelatedEntityType = eventEntity.RelatedEntityType,
                BranchId = eventEntity.BranchId,
                BranchName = eventEntity.Branch?.BranchName,
                HasReminder = eventEntity.HasReminder,
                ReminderMinutes = eventEntity.ReminderMinutes,
                ReminderSent = eventEntity.ReminderSent,
                Color = eventEntity.Color,
                IsActive = eventEntity.IsActive,
                IsAutoGenerated = eventEntity.IsAutoGenerated,
                RecurrencePattern = eventEntity.RecurrencePattern,
                Notes = eventEntity.Notes,
                CreatedBy = eventEntity.CreatedBy,
                CreatedByName = eventEntity.CreatedByUser.UserProfile?.FullName ?? eventEntity.CreatedByUser.Username,
                CreatedAt = eventEntity.CreatedAt,
                UpdatedAt = eventEntity.UpdatedAt
            };

            await PopulateRelatedEntityDetails(new List<CalendarEventDto> { eventDto });
            return eventDto;
        }

        public async Task<CalendarEventDto> CreateEventAsync(CreateCalendarEventDto createDto, int createdBy)
        {
            // ✅ CRITICAL - Validate user exists before creating event
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Id == createdBy);
            if (user == null)
            {
                throw new InvalidOperationException($"User with ID {createdBy} not found. Cannot create calendar event.");
            }

            // ✅ CRITICAL - Validate branch exists if specified
            if (createDto.BranchId.HasValue)
            {
                var branch = await _context.Branches.FirstOrDefaultAsync(b => b.Id == createDto.BranchId.Value && b.IsActive);
                if (branch == null)
                {
                    throw new InvalidOperationException($"Branch with ID {createDto.BranchId.Value} not found or is inactive.");
                }
            }

            var validationErrors = await ValidateEventDataAsync(createDto);
            if (validationErrors.Any())
            {
                throw new ArgumentException($"Validation failed: {string.Join(", ", validationErrors)}");
            }

            var eventEntity = new CalendarEvent
            {
                Title = createDto.Title,
                Description = createDto.Description,
                StartDate = createDto.StartDate,
                EndDate = createDto.EndDate,
                IsAllDay = createDto.IsAllDay,
                EventType = createDto.EventType,
                Priority = createDto.Priority,
                ActionUrl = createDto.ActionUrl,
                RelatedEntityId = createDto.RelatedEntityId,
                RelatedEntityType = createDto.RelatedEntityType,
                BranchId = createDto.BranchId,
                HasReminder = createDto.HasReminder,
                ReminderMinutes = createDto.ReminderMinutes,
                Color = createDto.Color,
                RecurrencePattern = createDto.RecurrencePattern,
                Notes = createDto.Notes,
                CreatedBy = createdBy,
                UpdatedBy = createdBy,  // Set initial UpdatedBy to same as CreatedBy
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            _context.CalendarEvents.Add(eventEntity);
            
            try
            {
                await _context.SaveChangesAsync();
                
                _logger.LogInformation("Calendar event '{Title}' created successfully by user {UserId}", 
                    createDto.Title, createdBy);
            }
            catch (Microsoft.EntityFrameworkCore.DbUpdateException ex)
            {
                _logger.LogError(ex, "Database error creating calendar event '{Title}' by user {UserId}", 
                    createDto.Title, createdBy);
                
                if (ex.InnerException?.Message?.Contains("FOREIGN KEY constraint") == true)
                {
                    throw new InvalidOperationException("Foreign key constraint error. User or branch reference is invalid.", ex);
                }
                
                throw new InvalidOperationException("Database error occurred while creating calendar event.", ex);
            }

            // Create reminders if needed
            if (eventEntity.HasReminder && eventEntity.ReminderMinutes.HasValue)
            {
                await CreateEventRemindersAsync(eventEntity.Id);
            }

            _logger.LogInformation("Calendar event created: {EventId} - {Title} by user {UserId}", 
                eventEntity.Id, eventEntity.Title, createdBy);

            return await GetEventByIdAsync(eventEntity.Id, createdBy) ?? 
                throw new InvalidOperationException("Failed to retrieve created event");
        }

        public async Task<CalendarEventDto?> UpdateEventAsync(int eventId, UpdateCalendarEventDto updateDto, int updatedBy)
        {
            var eventEntity = await _context.CalendarEvents.FindAsync(eventId);
            if (eventEntity == null)
                return null;

            // Check permissions
            var canAccess = await CanUserAccessEventAsync(eventId, updatedBy);
            if (!canAccess)
                return null;

            // Update fields that are provided
            if (!string.IsNullOrEmpty(updateDto.Title))
                eventEntity.Title = updateDto.Title;

            if (updateDto.Description != null)
                eventEntity.Description = updateDto.Description;

            if (updateDto.StartDate.HasValue)
                eventEntity.StartDate = updateDto.StartDate.Value;

            if (updateDto.EndDate.HasValue)
                eventEntity.EndDate = updateDto.EndDate.Value;

            if (updateDto.IsAllDay.HasValue)
                eventEntity.IsAllDay = updateDto.IsAllDay.Value;

            if (updateDto.EventType.HasValue)
                eventEntity.EventType = updateDto.EventType.Value;

            if (updateDto.Priority.HasValue)
                eventEntity.Priority = updateDto.Priority.Value;

            if (updateDto.ActionUrl != null)
                eventEntity.ActionUrl = updateDto.ActionUrl;

            if (updateDto.RelatedEntityId.HasValue)
                eventEntity.RelatedEntityId = updateDto.RelatedEntityId.Value;

            if (updateDto.RelatedEntityType != null)
                eventEntity.RelatedEntityType = updateDto.RelatedEntityType;

            if (updateDto.BranchId.HasValue)
                eventEntity.BranchId = updateDto.BranchId.Value;

            if (updateDto.HasReminder.HasValue)
            {
                eventEntity.HasReminder = updateDto.HasReminder.Value;
                
                // Reset reminder status if reminder settings changed
                if (updateDto.HasReminder.Value && updateDto.ReminderMinutes.HasValue)
                {
                    eventEntity.ReminderMinutes = updateDto.ReminderMinutes.Value;
                    eventEntity.ReminderSent = false;
                    
                    // Remove old reminders and create new ones
                    var oldReminders = await _context.CalendarEventReminders
                        .Where(r => r.CalendarEventId == eventId && !r.IsSent)
                        .ToListAsync();
                    _context.CalendarEventReminders.RemoveRange(oldReminders);
                    
                    await CreateEventRemindersAsync(eventId);
                }
            }

            if (updateDto.Color != null)
                eventEntity.Color = updateDto.Color;

            if (updateDto.IsActive.HasValue)
                eventEntity.IsActive = updateDto.IsActive.Value;

            if (updateDto.RecurrencePattern != null)
                eventEntity.RecurrencePattern = updateDto.RecurrencePattern;

            if (updateDto.Notes != null)
                eventEntity.Notes = updateDto.Notes;

            eventEntity.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync();

            _logger.LogInformation("Calendar event updated: {EventId} - {Title} by user {UserId}", 
                eventEntity.Id, eventEntity.Title, updatedBy);

            return await GetEventByIdAsync(eventId, updatedBy);
        }

        public async Task<bool> DeleteEventAsync(int eventId, int deletedBy)
        {
            var eventEntity = await _context.CalendarEvents.FindAsync(eventId);
            if (eventEntity == null)
                return false;

            // Check permissions
            var canAccess = await CanUserAccessEventAsync(eventId, deletedBy);
            if (!canAccess)
                return false;

            // Remove associated reminders
            var reminders = await _context.CalendarEventReminders
                .Where(r => r.CalendarEventId == eventId)
                .ToListAsync();
            _context.CalendarEventReminders.RemoveRange(reminders);

            _context.CalendarEvents.Remove(eventEntity);
            await _context.SaveChangesAsync();

            _logger.LogInformation("Calendar event deleted: {EventId} - {Title} by user {UserId}", 
                eventEntity.Id, eventEntity.Title, deletedBy);

            return true;
        }

        public async Task<int> BulkOperationAsync(BulkEventOperationDto operationDto, int requestingUserId)
        {
            var affectedCount = 0;

            foreach (var eventId in operationDto.EventIds)
            {
                var canAccess = await CanUserAccessEventAsync(eventId, requestingUserId);
                if (!canAccess)
                    continue;

                var eventEntity = await _context.CalendarEvents.FindAsync(eventId);
                if (eventEntity == null)
                    continue;

                switch (operationDto.Operation.ToLower())
                {
                    case "activate":
                        eventEntity.IsActive = true;
                        affectedCount++;
                        break;
                    case "deactivate":
                        eventEntity.IsActive = false;
                        affectedCount++;
                        break;
                    case "delete":
                        var reminders = await _context.CalendarEventReminders
                            .Where(r => r.CalendarEventId == eventId)
                            .ToListAsync();
                        _context.CalendarEventReminders.RemoveRange(reminders);
                        _context.CalendarEvents.Remove(eventEntity);
                        affectedCount++;
                        break;
                }

                eventEntity.UpdatedAt = DateTime.UtcNow;
            }

            if (affectedCount > 0)
            {
                await _context.SaveChangesAsync();
                _logger.LogInformation("Bulk operation {Operation} applied to {Count} events by user {UserId}", 
                    operationDto.Operation, affectedCount, requestingUserId);
            }

            return affectedCount;
        }

        // ==================== CALENDAR VIEWS ==================== //

        public async Task<CalendarMonthViewDto> GetMonthViewAsync(int year, int month, int? branchId, int requestingUserId)
        {
            var startDate = new DateTime(year, month, 1);
            var endDate = startDate.AddMonths(1).AddDays(-1);

            var events = await GetEventsByDateRangeAsync(startDate, endDate, branchId, requestingUserId);

            var eventCountByDay = events
                .GroupBy(e => e.StartDate.Day)
                .ToDictionary(g => g.Key, g => g.Count());

            var criticalEvents = events
                .Where(e => e.Priority == EventPriority.Critical)
                .OrderBy(e => e.StartDate)
                .ToList();

            return new CalendarMonthViewDto
            {
                Year = year,
                Month = month,
                Events = events,
                EventCountByDay = eventCountByDay,
                CriticalEvents = criticalEvents
            };
        }

        public async Task<DailyEventsSummaryDto> GetDailySummaryAsync(DateTime date, int? branchId, int requestingUserId)
        {
            var startOfDay = date.Date;
            var endOfDay = startOfDay.AddDays(1).AddTicks(-1);

            var events = await GetEventsByDateRangeAsync(startOfDay, endOfDay, branchId, requestingUserId);

            var eventsByType = events
                .GroupBy(e => e.EventType)
                .ToDictionary(g => g.Key, g => g.Count());

            var pendingReminders = await _context.CalendarEventReminders
                .Where(r => r.ScheduledTime.Date == date.Date && !r.IsSent)
                .CountAsync();

            return new DailyEventsSummaryDto
            {
                Date = date,
                Events = events,
                TotalEvents = events.Count,
                CriticalEvents = events.Count(e => e.Priority == EventPriority.Critical),
                PendingReminders = pendingReminders,
                EventsByType = eventsByType
            };
        }

        public async Task<CalendarDashboardDto> GetDashboardAsync(int requestingUserId, int? branchId = null)
        {
            var today = DateTime.Today;
            var tomorrow = today.AddDays(1);
            var nextWeek = today.AddDays(7);

            var todayEvents = await GetEventsByDateRangeAsync(today, tomorrow.AddTicks(-1), branchId, requestingUserId);
            var upcomingEvents = await GetEventsByDateRangeAsync(tomorrow, nextWeek, branchId, requestingUserId);
            var overdueEvents = await GetOverdueEventsAsync(branchId, requestingUserId);

            var monthStart = new DateTime(today.Year, today.Month, 1);
            var monthEnd = monthStart.AddMonths(1).AddTicks(-1);
            var monthEvents = await GetEventsByDateRangeAsync(monthStart, monthEnd, branchId, requestingUserId);

            var eventTypeCount = monthEvents
                .GroupBy(e => e.EventType)
                .ToDictionary(g => g.Key, g => g.Count());

            var priorityCount = monthEvents
                .GroupBy(e => e.Priority)
                .ToDictionary(g => g.Key, g => g.Count());

            var pendingReminders = await _context.CalendarEventReminders
                .Where(r => !r.IsSent && r.ScheduledTime <= DateTime.UtcNow.AddDays(1))
                .CountAsync();

            return new CalendarDashboardDto
            {
                Today = today,
                TodayEvents = todayEvents,
                UpcomingEvents = upcomingEvents.Take(10).ToList(),
                OverdueEvents = overdueEvents,
                EventTypeCount = eventTypeCount,
                PriorityCount = priorityCount,
                PendingReminders = pendingReminders,
                TotalEventsThisMonth = monthEvents.Count
            };
        }

        // ==================== BUSINESS INTEGRATION ==================== //

        public async Task<int> AutoGenerateEventsAsync(AutoGenerateEventsDto generateDto, int requestingUserId)
        {
            var totalGenerated = 0;

            try
            {
                if (generateDto.GenerateProductExpiry)
                {
                    var daysAhead = (int)(generateDto.EndDate - generateDto.StartDate).TotalDays;
                    totalGenerated += await GenerateProductExpiryEventsAsync(generateDto.BranchId, daysAhead, requestingUserId);
                }

                if (generateDto.GenerateFactureDue)
                {
                    var daysAhead = (int)(generateDto.EndDate - generateDto.StartDate).TotalDays;
                    totalGenerated += await GenerateFactureDueEventsAsync(generateDto.BranchId, daysAhead, requestingUserId);
                }

                if (generateDto.GenerateMemberPayments)
                {
                    var daysAhead = (int)(generateDto.EndDate - generateDto.StartDate).TotalDays;
                    totalGenerated += await GenerateMemberPaymentEventsAsync(generateDto.BranchId, daysAhead, requestingUserId);
                }

                _logger.LogInformation("Auto-generated {Count} calendar events for user {UserId}", 
                    totalGenerated, requestingUserId);

                return totalGenerated;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error auto-generating calendar events");
                throw;
            }
        }

        public async Task<int> GenerateProductExpiryEventsAsync(int? branchId, int daysAhead, int requestingUserId)
        {
            var cutoffDate = DateTime.Today.AddDays(daysAhead);
            
            var expiringProducts = await _context.ProductBatches
                .Include(pb => pb.Product)
                .Include(pb => pb.Branch)
                .Where(pb => pb.ExpiryDate.HasValue &&
                           pb.ExpiryDate.Value.Date <= cutoffDate &&
                           pb.ExpiryDate.Value.Date >= DateTime.Today &&
                           pb.CurrentStock > 0 &&
                           (branchId == null || pb.BranchId == branchId))
                .ToListAsync();

            var generatedCount = 0;

            foreach (var batch in expiringProducts)
            {
                var eventTitle = $"Produk akan kadaluarsa: {batch.Product?.Name}";
                var daysUntilExpiry = (int)(batch.ExpiryDate!.Value.Date - DateTime.Today).TotalDays;
                
                var priority = daysUntilExpiry switch
                {
                    <= 1 => EventPriority.Critical,
                    <= 3 => EventPriority.High,
                    <= 7 => EventPriority.Normal,
                    _ => EventPriority.Low
                };

                // Check if event already exists
                var existingEvent = await _context.CalendarEvents
                    .FirstOrDefaultAsync(e => e.RelatedEntityType == "ProductBatch" &&
                                            e.RelatedEntityId == batch.Id &&
                                            e.EventType == CalendarEventType.ProductExpiry &&
                                            e.IsAutoGenerated);

                if (existingEvent == null)
                {
                    var calendarEvent = new CalendarEvent
                    {
                        Title = eventTitle,
                        Description = $"Batch produk {batch.Product?.Name} akan kadaluarsa pada {batch.ExpiryDate.Value:dd/MM/yyyy}. Stok tersisa: {batch.CurrentStock}",
                        StartDate = batch.ExpiryDate.Value.Date,
                        IsAllDay = true,
                        EventType = CalendarEventType.ProductExpiry,
                        Priority = priority,
                        RelatedEntityId = batch.Id,
                        RelatedEntityType = "ProductBatch",
                        BranchId = batch.BranchId,
                        IsAutoGenerated = true,
                        HasReminder = true,
                        ReminderMinutes = daysUntilExpiry <= 1 ? 60 : 1440, // 1 hour for critical, 1 day for others
                        Color = priority == EventPriority.Critical ? "#FF0000" : "#FF9800",
                        CreatedBy = requestingUserId,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.CalendarEvents.Add(calendarEvent);
                    generatedCount++;
                }
            }

            if (generatedCount > 0)
            {
                await _context.SaveChangesAsync();
                
                // Create reminders for new events
                var newEvents = await _context.CalendarEvents
                    .Where(e => e.CreatedBy == requestingUserId &&
                              e.EventType == CalendarEventType.ProductExpiry &&
                              e.IsAutoGenerated &&
                              e.HasReminder)
                    .ToListAsync();

                foreach (var eventEntity in newEvents)
                {
                    await CreateEventRemindersAsync(eventEntity.Id);
                }
            }

            return generatedCount;
        }

        public async Task<int> GenerateFactureDueEventsAsync(int? branchId, int daysAhead, int requestingUserId)
        {
            var cutoffDate = DateTime.Today.AddDays(daysAhead);
            
            var dueFactures = await _context.Factures
                .Include(f => f.Supplier)
                .Include(f => f.Branch)
                .Where(f => f.DueDate.Date <= cutoffDate &&
                           f.DueDate.Date >= DateTime.Today &&
                           f.Status != FactureStatus.Paid &&
                           (branchId == null || f.BranchId == branchId))
                .ToListAsync();

            var generatedCount = 0;

            foreach (var facture in dueFactures)
            {
                var eventTitle = $"Faktur jatuh tempo: {facture.Supplier?.CompanyName}";
                var daysUntilDue = (int)(facture.DueDate.Date - DateTime.Today).TotalDays;
                
                var priority = daysUntilDue switch
                {
                    <= 0 => EventPriority.Critical,
                    <= 3 => EventPriority.High,
                    <= 7 => EventPriority.Normal,
                    _ => EventPriority.Low
                };

                // Check if event already exists
                var existingEvent = await _context.CalendarEvents
                    .FirstOrDefaultAsync(e => e.RelatedEntityType == "Facture" &&
                                            e.RelatedEntityId == facture.Id &&
                                            e.EventType == CalendarEventType.FactureDue &&
                                            e.IsAutoGenerated);

                if (existingEvent == null)
                {
                    var calendarEvent = new CalendarEvent
                    {
                        Title = eventTitle,
                        Description = $"Faktur dari {facture.Supplier?.CompanyName} jatuh tempo pada {facture.DueDate:dd/MM/yyyy}. Jumlah: {facture.TotalAmount:C0}",
                        StartDate = facture.DueDate.Date,
                        IsAllDay = true,
                        EventType = CalendarEventType.FactureDue,
                        Priority = priority,
                        RelatedEntityId = facture.Id,
                        RelatedEntityType = "Facture",
                        BranchId = facture.BranchId,
                        IsAutoGenerated = true,
                        HasReminder = true,
                        ReminderMinutes = daysUntilDue <= 0 ? 60 : 1440,
                        Color = priority == EventPriority.Critical ? "#FF0000" : "#2196F3",
                        CreatedBy = requestingUserId,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.CalendarEvents.Add(calendarEvent);
                    generatedCount++;
                }
            }

            if (generatedCount > 0)
            {
                await _context.SaveChangesAsync();
                
                // Create reminders for new events
                var newEvents = await _context.CalendarEvents
                    .Where(e => e.CreatedBy == requestingUserId &&
                              e.EventType == CalendarEventType.FactureDue &&
                              e.IsAutoGenerated &&
                              e.HasReminder)
                    .ToListAsync();

                foreach (var eventEntity in newEvents)
                {
                    await CreateEventRemindersAsync(eventEntity.Id);
                }
            }

            return generatedCount;
        }

        public async Task<int> GenerateMemberPaymentEventsAsync(int? branchId, int daysAhead, int requestingUserId)
        {
            // This would generate events for member credit payments or subscriptions
            // Implementation depends on business rules for member payments
            var generatedCount = 0;

            var overdueMembers = await _context.Members
                .Where(m => m.CurrentDebt > 0) // Members with outstanding debt
                .ToListAsync();

            foreach (var member in overdueMembers)
            {
                var eventTitle = $"Tagihan member: {member.Name}";
                var paymentAmount = member.CurrentDebt;

                // Check if event already exists for this member
                var existingEvent = await _context.CalendarEvents
                    .FirstOrDefaultAsync(e => e.RelatedEntityType == "Member" &&
                                            e.RelatedEntityId == member.Id &&
                                            e.EventType == CalendarEventType.MemberPayment &&
                                            e.IsAutoGenerated &&
                                            e.StartDate.Date == DateTime.Today);

                if (existingEvent == null)
                {
                    var calendarEvent = new CalendarEvent
                    {
                        Title = eventTitle,
                        Description = $"Member {member.Name} memiliki tagihan sebesar {paymentAmount:C0}. Perlu follow-up untuk pembayaran.",
                        StartDate = DateTime.Today,
                        IsAllDay = true,
                        EventType = CalendarEventType.MemberPayment,
                        Priority = paymentAmount > 100000 ? EventPriority.High : EventPriority.Normal,
                        RelatedEntityId = member.Id,
                        RelatedEntityType = "Member",
                        BranchId = branchId, // Use the provided branchId parameter
                        IsAutoGenerated = true,
                        HasReminder = true,
                        ReminderMinutes = 480, // 8 hours
                        Color = "#9C27B0",
                        CreatedBy = requestingUserId,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.CalendarEvents.Add(calendarEvent);
                    generatedCount++;
                }
            }

            if (generatedCount > 0)
            {
                await _context.SaveChangesAsync();
                
                // Create reminders for new events
                var newEvents = await _context.CalendarEvents
                    .Where(e => e.CreatedBy == requestingUserId &&
                              e.EventType == CalendarEventType.MemberPayment &&
                              e.IsAutoGenerated &&
                              e.HasReminder)
                    .ToListAsync();

                foreach (var eventEntity in newEvents)
                {
                    await CreateEventRemindersAsync(eventEntity.Id);
                }
            }

            return generatedCount;
        }

        public async Task<List<CalendarEventDto>> GetEventsForEntityAsync(string entityType, int entityId, int requestingUserId)
        {
            var events = await _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                .Include(e => e.Branch)
                .Where(e => e.RelatedEntityType == entityType &&
                           e.RelatedEntityId == entityId &&
                           e.IsActive)
                .OrderBy(e => e.StartDate)
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                events = events.Where(e => e.BranchId == user!.BranchId || e.BranchId == null).ToList();
            }

            await PopulateRelatedEntityDetails(events);
            return events;
        }

        // ==================== REMINDER MANAGEMENT ==================== //

        public async Task<List<EventReminderDto>> GetUpcomingRemindersAsync(DateTime beforeTime)
        {
            var reminders = await _context.CalendarEventReminders
                .Include(r => r.CalendarEvent)
                .Include(r => r.User)
                .Where(r => !r.IsSent &&
                           r.ScheduledTime <= beforeTime &&
                           r.AttemptCount < 3) // Max 3 attempts
                .OrderBy(r => r.ScheduledTime)
                .Select(r => new EventReminderDto
                {
                    Id = r.Id,
                    CalendarEventId = r.CalendarEventId,
                    ScheduledTime = r.ScheduledTime,
                    SentTime = r.SentTime,
                    IsSent = r.IsSent,
                    AttemptCount = r.AttemptCount,
                    ErrorMessage = r.ErrorMessage,
                    DeliveryMethod = r.DeliveryMethod,
                    UserId = r.UserId,
                    TargetRole = r.TargetRole,
                    EventTitle = r.CalendarEvent.Title,
                    EventPriority = r.CalendarEvent.Priority
                })
                .ToListAsync();

            return reminders;
        }

        public async Task<bool> MarkReminderSentAsync(int reminderId, DateTime sentTime, bool success, string? errorMessage = null)
        {
            var reminder = await _context.CalendarEventReminders.FindAsync(reminderId);
            if (reminder == null)
                return false;

            reminder.SentTime = sentTime;
            reminder.IsSent = success;
            reminder.AttemptCount++;
            
            if (!success && !string.IsNullOrEmpty(errorMessage))
            {
                reminder.ErrorMessage = errorMessage;
            }

            await _context.SaveChangesAsync();
            return true;
        }

        public async Task<int> CreateEventRemindersAsync(int eventId)
        {
            var eventEntity = await _context.CalendarEvents
                .Include(e => e.Branch)
                .FirstOrDefaultAsync(e => e.Id == eventId);

            if (eventEntity == null || !eventEntity.HasReminder || !eventEntity.ReminderMinutes.HasValue)
                return 0;

            // Calculate reminder time
            var reminderTime = eventEntity.StartDate.AddMinutes(-eventEntity.ReminderMinutes.Value);

            // Don't create reminders for past events
            if (reminderTime <= DateTime.UtcNow)
                return 0;

            var remindersCreated = 0;

            // Create role-based reminders based on event type and priority
            var targetRoles = GetTargetRolesForEvent(eventEntity);
            
            foreach (var role in targetRoles)
            {
                var reminder = new CalendarEventReminder
                {
                    CalendarEventId = eventId,
                    ScheduledTime = reminderTime,
                    TargetRole = role,
                    DeliveryMethod = "Push",
                    AttemptCount = 0
                };

                _context.CalendarEventReminders.Add(reminder);
                remindersCreated++;
            }

            if (remindersCreated > 0)
            {
                await _context.SaveChangesAsync();
                _logger.LogInformation("Created {Count} reminders for event {EventId}", remindersCreated, eventId);
            }

            return remindersCreated;
        }

        public async Task<List<EventReminderDto>> GetUserPendingRemindersAsync(int userId, int? branchId = null)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return new List<EventReminderDto>();

            var reminders = await _context.CalendarEventReminders
                .Include(r => r.CalendarEvent)
                .Where(r => !r.IsSent &&
                           r.ScheduledTime <= DateTime.UtcNow.AddHours(24) && // Next 24 hours
                           (r.UserId == userId || r.TargetRole == user.Role) &&
                           (branchId == null || r.CalendarEvent.BranchId == branchId || r.CalendarEvent.BranchId == null))
                .OrderBy(r => r.ScheduledTime)
                .Select(r => new EventReminderDto
                {
                    Id = r.Id,
                    CalendarEventId = r.CalendarEventId,
                    ScheduledTime = r.ScheduledTime,
                    SentTime = r.SentTime,
                    IsSent = r.IsSent,
                    AttemptCount = r.AttemptCount,
                    ErrorMessage = r.ErrorMessage,
                    DeliveryMethod = r.DeliveryMethod,
                    UserId = r.UserId,
                    TargetRole = r.TargetRole,
                    EventTitle = r.CalendarEvent.Title,
                    EventPriority = r.CalendarEvent.Priority
                })
                .ToListAsync();

            return reminders;
        }

        // ==================== STATISTICS & ANALYTICS ==================== //

        public async Task<CalendarEventStatsDto> GetEventStatisticsAsync(int requestingUserId, int? branchId = null, DateTime? fromDate = null, DateTime? toDate = null)
        {
            var query = _context.CalendarEvents.AsQueryable();

            // Apply date filters
            if (fromDate.HasValue)
                query = query.Where(e => e.StartDate >= fromDate.Value);

            if (toDate.HasValue)
                query = query.Where(e => e.StartDate <= toDate.Value);

            // Apply branch filter
            if (branchId.HasValue)
                query = query.Where(e => e.BranchId == branchId.Value || e.BranchId == null);

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            var events = await query.ToListAsync();

            var totalEvents = events.Count;
            var activeEvents = events.Count(e => e.IsActive);
            var autoGeneratedEvents = events.Count(e => e.IsAutoGenerated);
            var eventsWithReminders = events.Count(e => e.HasReminder);
            var completedEvents = events.Count(e => e.StartDate < DateTime.UtcNow);

            var eventsByType = events
                .GroupBy(e => e.EventType)
                .ToDictionary(g => g.Key, g => g.Count());

            var eventsByPriority = events
                .GroupBy(e => e.Priority)
                .ToDictionary(g => g.Key, g => g.Count());

            var eventsByMonth = events
                .GroupBy(e => e.StartDate.ToString("yyyy-MM"))
                .ToDictionary(g => g.Key, g => g.Count());

            return new CalendarEventStatsDto
            {
                TotalEvents = totalEvents,
                ActiveEvents = activeEvents,
                AutoGeneratedEvents = autoGeneratedEvents,
                EventsWithReminders = eventsWithReminders,
                CompletedEvents = completedEvents,
                EventsByType = eventsByType,
                EventsByPriority = eventsByPriority,
                EventsByMonth = eventsByMonth
            };
        }

        public async Task<List<CalendarEventDto>> GetEventsRequiringAttentionAsync(int requestingUserId, int? branchId = null)
        {
            var query = _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .Where(e => e.IsActive &&
                          ((e.StartDate < DateTime.UtcNow && e.Priority >= EventPriority.High) || // Overdue high priority
                           e.Priority == EventPriority.Critical || // All critical events
                           (e.HasReminder && !e.ReminderSent && e.StartDate <= DateTime.UtcNow.AddDays(1)))); // Reminders not sent

            if (branchId.HasValue)
                query = query.Where(e => e.BranchId == branchId.Value || e.BranchId == null);

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            var events = await query
                .OrderBy(e => e.Priority)
                .ThenBy(e => e.StartDate)
                .Take(20) // Limit to 20 most urgent
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            await PopulateRelatedEntityDetails(events);
            return events;
        }

        public async Task<List<CalendarEventDto>> GetUpcomingEventsAsync(int requestingUserId, int days = 7, int? branchId = null)
        {
            var startDate = DateTime.Today;
            var endDate = startDate.AddDays(days);

            return await GetEventsByDateRangeAsync(startDate, endDate, branchId, requestingUserId);
        }

        // ==================== VALIDATION & UTILITIES ==================== //

        public async Task<List<string>> ValidateEventDataAsync(CreateCalendarEventDto createDto)
        {
            var errors = new List<string>();

            if (string.IsNullOrWhiteSpace(createDto.Title))
                errors.Add("Judul event harus diisi");

            if (createDto.StartDate < DateTime.Today.AddDays(-1))
                errors.Add("Tanggal mulai tidak boleh lebih dari 1 hari yang lalu");

            if (createDto.EndDate.HasValue && createDto.EndDate.Value < createDto.StartDate)
                errors.Add("Tanggal selesai tidak boleh lebih awal dari tanggal mulai");

            if (createDto.HasReminder && !createDto.ReminderMinutes.HasValue)
                errors.Add("Waktu reminder harus diisi jika reminder diaktifkan");

            if (createDto.ReminderMinutes.HasValue && createDto.ReminderMinutes.Value < 0)
                errors.Add("Waktu reminder tidak boleh negatif");

            if (createDto.BranchId.HasValue)
            {
                var branchExists = await _context.Branches.AnyAsync(b => b.Id == createDto.BranchId.Value);
                if (!branchExists)
                    errors.Add("Branch yang dipilih tidak ditemukan");
            }

            if (!string.IsNullOrEmpty(createDto.Color) && !IsValidHexColor(createDto.Color))
                errors.Add("Format warna tidak valid (gunakan format hex, contoh: #FF0000)");

            return errors;
        }

        public async Task<bool> CanUserAccessEventAsync(int eventId, int userId)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return false;

            var eventEntity = await _context.CalendarEvents.FindAsync(eventId);
            if (eventEntity == null)
                return false;

            // Admin can access all events
            if (user.Role == "Admin")
                return true;

            // Users can access events in their branch or global events
            return eventEntity.BranchId == null || eventEntity.BranchId == user.BranchId;
        }

        public async Task<int> CleanupOldEventsAsync(int olderThanDays)
        {
            var cutoffDate = DateTime.UtcNow.AddDays(-olderThanDays);
            
            var oldEvents = await _context.CalendarEvents
                .Where(e => e.CreatedAt < cutoffDate &&
                           e.StartDate < DateTime.UtcNow.AddDays(-7)) // Only cleanup events that are also past
                .ToListAsync();

            if (oldEvents.Any())
            {
                // Remove associated reminders first
                var eventIds = oldEvents.Select(e => e.Id).ToList();
                var reminders = await _context.CalendarEventReminders
                    .Where(r => eventIds.Contains(r.CalendarEventId))
                    .ToListAsync();
                
                _context.CalendarEventReminders.RemoveRange(reminders);
                _context.CalendarEvents.RemoveRange(oldEvents);
                
                await _context.SaveChangesAsync();
                
                _logger.LogInformation("Cleaned up {Count} old calendar events", oldEvents.Count);
            }

            return oldEvents.Count;
        }

        public async Task<List<CalendarEventDto>> SearchEventsAsync(string searchTerm, int requestingUserId, int? branchId = null, int maxResults = 20)
        {
            var query = _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .Where(e => e.IsActive);

            if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                var term = searchTerm.ToLower();
                query = query.Where(e => e.Title.ToLower().Contains(term) ||
                                        (e.Description != null && e.Description.ToLower().Contains(term)) ||
                                        (e.Notes != null && e.Notes.ToLower().Contains(term)));
            }

            if (branchId.HasValue)
                query = query.Where(e => e.BranchId == branchId.Value || e.BranchId == null);

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            var events = await query
                .OrderBy(e => e.StartDate)
                .Take(maxResults)
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            await PopulateRelatedEntityDetails(events);
            return events;
        }

        // ==================== PRIVATE HELPER METHODS ==================== //

        private async Task PopulateRelatedEntityDetails(List<CalendarEventDto> events)
        {
            foreach (var eventDto in events)
            {
                if (eventDto.RelatedEntityId.HasValue && !string.IsNullOrEmpty(eventDto.RelatedEntityType))
                {
                    switch (eventDto.RelatedEntityType)
                    {
                        case "Product":
                            var product = await _context.Products.FindAsync(eventDto.RelatedEntityId.Value);
                            if (product != null)
                            {
                                eventDto.RelatedEntityName = product.Name;
                                eventDto.RelatedEntityDetails = $"Barcode: {product.Barcode}";
                            }
                            break;

                        case "ProductBatch":
                            var batch = await _context.ProductBatches
                                .Include(pb => pb.Product)
                                .FirstOrDefaultAsync(pb => pb.Id == eventDto.RelatedEntityId.Value);
                            if (batch != null)
                            {
                                eventDto.RelatedEntityName = batch.Product?.Name;
                                eventDto.RelatedEntityDetails = $"Batch: {batch.BatchNumber}, Stok: {batch.CurrentStock}";
                            }
                            break;

                        case "Facture":
                            var facture = await _context.Factures
                                .Include(f => f.Supplier)
                                .FirstOrDefaultAsync(f => f.Id == eventDto.RelatedEntityId.Value);
                            if (facture != null)
                            {
                                eventDto.RelatedEntityName = facture.Supplier?.CompanyName;
                                eventDto.RelatedEntityDetails = $"No. Faktur: {facture.SupplierInvoiceNumber}, Total: {facture.TotalAmount:C0}";
                            }
                            break;

                        case "Member":
                            var member = await _context.Members.FindAsync(eventDto.RelatedEntityId.Value);
                            if (member != null)
                            {
                                eventDto.RelatedEntityName = member.Name;
                                eventDto.RelatedEntityDetails = $"Phone: {member.Phone}, Debt: {member.CurrentDebt:C0}";
                            }
                            break;

                        case "Supplier":
                            var supplier = await _context.Suppliers.FindAsync(eventDto.RelatedEntityId.Value);
                            if (supplier != null)
                            {
                                eventDto.RelatedEntityName = supplier.CompanyName;
                                eventDto.RelatedEntityDetails = $"Contact: {supplier.ContactPerson}";
                            }
                            break;
                    }
                }
            }
        }

        private async Task<List<CalendarEventDto>> GetOverdueEventsAsync(int? branchId, int requestingUserId)
        {
            var now = DateTime.UtcNow;
            
            var query = _context.CalendarEvents
                .Include(e => e.CreatedByUser)
                    .ThenInclude(u => u.UserProfile)
                .Include(e => e.Branch)
                .Where(e => e.IsActive &&
                           e.StartDate < now &&
                           e.Priority >= EventPriority.High); // Only high priority and critical overdue events

            if (branchId.HasValue)
                query = query.Where(e => e.BranchId == branchId.Value || e.BranchId == null);

            // Apply role-based filtering
            var user = await _context.Users.FindAsync(requestingUserId);
            if (user?.Role != "Admin")
            {
                query = query.Where(e => e.BranchId == user!.BranchId || e.BranchId == null);
            }

            var events = await query
                .OrderBy(e => e.StartDate)
                .Take(10) // Limit to 10 most urgent overdue events
                .Select(e => new CalendarEventDto
                {
                    Id = e.Id,
                    Title = e.Title,
                    Description = e.Description,
                    StartDate = e.StartDate,
                    EndDate = e.EndDate,
                    IsAllDay = e.IsAllDay,
                    EventType = e.EventType,
                    Priority = e.Priority,
                    ActionUrl = e.ActionUrl,
                    RelatedEntityId = e.RelatedEntityId,
                    RelatedEntityType = e.RelatedEntityType,
                    BranchId = e.BranchId,
                    BranchName = e.Branch != null ? e.Branch.BranchName : null,
                    HasReminder = e.HasReminder,
                    ReminderMinutes = e.ReminderMinutes,
                    ReminderSent = e.ReminderSent,
                    Color = e.Color,
                    IsActive = e.IsActive,
                    IsAutoGenerated = e.IsAutoGenerated,
                    RecurrencePattern = e.RecurrencePattern,
                    Notes = e.Notes,
                    CreatedBy = e.CreatedBy,
                    CreatedByName = e.CreatedByUser.UserProfile != null ? e.CreatedByUser.UserProfile.FullName : e.CreatedByUser.Username,
                    CreatedAt = e.CreatedAt,
                    UpdatedAt = e.UpdatedAt
                })
                .ToListAsync();

            await PopulateRelatedEntityDetails(events);
            return events;
        }

        private static List<string> GetTargetRolesForEvent(CalendarEvent eventEntity)
        {
            return eventEntity.EventType switch
            {
                CalendarEventType.ProductExpiry => new List<string> { "Admin", "Manager", "Inventory" },
                CalendarEventType.FactureDue => new List<string> { "Admin", "Manager", "Finance" },
                CalendarEventType.MemberPayment => new List<string> { "Admin", "Manager", "Cashier" },
                CalendarEventType.Inventory => new List<string> { "Admin", "Manager", "Inventory" },
                CalendarEventType.SystemMaintenance => new List<string> { "Admin" },
                _ when eventEntity.Priority == EventPriority.Critical => new List<string> { "Admin", "Manager" },
                _ => new List<string> { "Admin", "Manager" }
            };
        }

        private static bool IsValidHexColor(string color)
        {
            if (string.IsNullOrEmpty(color))
                return false;

            if (!color.StartsWith("#"))
                return false;

            if (color.Length != 7)
                return false;

            return color[1..].All(c => char.IsDigit(c) || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'));
        }
    }
}